·判断链表是否有环：设slow每次走1格,fast每次走两格.相遇时不为null则有环
·二叉查找树中序遍历可排序
·判断链表是否相交：若无环：判断尾指针是否相同。若有环：判断环入口是否在另一链表上
·寻找带环链表的入口：分别设指针从链表头与slow,fast相遇点出发，第一次相遇点为环入口
·寻找链表倒数第k个节点：设两个指针相隔k步，一起走到链表尾
·树的层次遍历：利用队列，每输出一个节点，其左右child分别入队
·c++字符串转int：(*digit - ‘0’)
·结构体与类的区别：
	1.结构体默认为public，类默认为private
	2.结构体定义时可用{}赋初值，类不能
	3.c语言中结构体不能包含函数，c++中可以
·结构体可以有构造函数
·不用比较运算符比较两数大小：
	1.(a / b) ? a : b
	2.z = a - b, (z >> 31) & 1 ? b : a
·移位优先级大于逻辑运算大于异或
·c++中变量的4种存储类型：auto、static、register、extern
·malloc/free为c/c++标准库函数，new/delete为c++运算符。库函数无法让编译器动态的执行构造/析构函数
·UNIX进程行为包括：代码段、数据段、堆栈段
·进程间通信：
	1.管道模型：内核中实现的先进先出缓冲，用文件名获得、共享
	2.消息传递机制：发送进程/线程向OS内核申请，OS将其地址空间内的消息缓存，并copy至接收进程/线程的地址空间
	3.信箱：类似消息传递，OScopy消息前，先缓存入接收方信箱中
	4.共享内存+信号量
·mutex互斥锁与临界区的区别：
	1.mutex支持进程/线程间的互斥访问，临界区为同一进程内的线程间
	2.mutex为内核对象，速度慢，临界区为非内核对象，在用户态操作，速度快
	3.mutex在linux/windows下都支持，临界区只支持于windows
·进程的三种基本状态：就绪状态、执行状态、阻塞状态
·LRU调页算法：最久没被访问的一页被替换， LFU调页算法：过去访问次数最少的一页被替换，FIFO调页算法：驻留内存最久的一页被替换
·c++的itoa函数：(num, char[], int) 将num转化为(2,8,10,16)进制的字符串。存入数组。strlen函数以'\0'为结尾计算
·c++的rand()函数：随机生成范围：0~32767，可用rand() % 100
·字符数组不要求以'\0'结尾，但其初始化要求以'\0'结尾。
·const成员函数不能修改类对象的数据成员，且可以
·函数重载：参数一定要不同，返回值可不同可相同
·关于形参：既可在函数声明，也可在函数定义处设置，但不能同时设置。形参默认值严格从左至右匹配
·观察者模式：一对多的依赖关系。多个观察者同时监听某一主题。
    优点：解除了主题与观察者的耦合，使各自的变化不会影响另一边的变化
    缺点：依赖关系并未完全解除，抽象通知者依旧依赖抽象观察者
    使用场景：客户一付款，财务需要开发票，出纳需要记账，配送员需要发货。
*OSI七层模型：   应用层-表示层-会话层-传输层-网络层----数据链路层-物理层
*TCP/IP四层模型：应用层-------------传输层-网际互联层-网络接口层
·TCP三次握手：1.客户端发送syn包(syn=j)至服务器，进入SYN_SEND状态
            2.服务器收到syn包，确认客户的SYN(ack=j+1)，同时还发送一个SYN包(syn=k)，即ACK+SYN包，进入SYN_RECV状态
            3.客户端收到SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，完毕后双方进入ESTABLISHED状态
·构造函数调用：先父类再子类。析构函数调用：先子类再父类
·类包含几个虚函数，则其对象就有几个虚函数指针，sizeof要4*n。虚函数指针指向虚函数表，第一项为类的typeinfo信息，之后项为类的所有虚函数地址。
·useful macro: 连接：#define Conn(x,y) x##y，加单引号：#define ToChar(x) #@x， 加双引号：#define ToString(x) #x
*最长公共子串：构造矩阵，字符相同则用左上角元素+1作为当前元素，否则置0。不断更新最大值。
·最长回文子串：将字符串逆转，寻找最长公共子串。
·静态链接库&动态链接库：静态优点：代码装载、执行快。静态缺点：生成的可执行文件体积大，包含公共代码，浪费。动态优点：节省内存，DLL文件与EXE独立，提高可维护性、可扩展性，可被不同编程语言调用，耦合度小。动态缺点：使用DLL的程序不是自完备的，速度慢。
·数据库的锁：1.共享(S)锁:使其他事务只可读，不可更新，读完释放。 2.排他(X)锁：使其他事务不可读，不可更新。事务结束才释放。 3.更新(U)锁：用来预定要对此页施加X锁，允许其他事务读，但不允许再施加U锁或X锁。当更新时，升级为X锁。事务结束才释放。
·孤儿进程：父进程退出，子进程还在运行。孤儿进程将被init(1号进程)收养。僵尸进程：父进程fork出子进程，若子进程退出，父进程未调用wait/waitpid获取子进程状态，则子进程的进程描述符仍保留在系统中，成为僵尸进程
·操作系统调度算法:1.时间片轮询 2.抢占式/非抢占式优先权调度算法 3.高响应比优先调度算法 4.多级反馈队列调度算法
·IP地址：A类：1.0.0.0 到126.0.0.0，B类：128.0.0.0到191.255.255.255，C类192.0.0.0到223.255.255.255
·同一进程内的线程共享：进程代码段、公有数据、打开的文件描述符、信号处理器。线程独有：寄存器值、堆栈
*海量数据处理：1.hash至内存范围大小(过大可多次hash)->用hash_map,trie树,最小堆等对数据进行统计计算->归并排序
	       2.BitMap,位图排序(前提:>0, 不重复)
·select与poll系统调用的区别：1.Select轮询，poll只轮询被内核唤醒并注册回调函数的描述符。2.select描述符数量有限(1024)，poll无限 3.select需要知道描述符数组大小并+1，poll不需要
·面向对象5大原则：1.单一职责原则(SRP) 2.开放封闭原则(OCP) 3.里式替换原则(LSP) 4.依赖倒置原则(DIP) 5.接口隔离原则(ISP)
